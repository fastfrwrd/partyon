var compressor = require('node-minify'),
	async = require('async'),
	_ = require('underscore'),
	less = require('less'),
	util = require('util'),
	fs = require('fs'),
	_path = require("path"),
	// sass = require('node-sass'),
	coffee = require('coffee-script');

_.str = require('underscore.string');


module.exports = function(config) {
	if (!config) config = {
		log: {
			info: function (){ console.log.apply(this,_.toArray(arguments)); },
			verbose: function (){ console.log.apply(this,_.toArray(arguments)); },
			debug: function (){ console.log.apply(this,_.toArray(arguments)); },
			warn: function (){ console.warn.apply(this,_.toArray(arguments)); },
			error: function (){ console.error.apply(this,_.toArray(arguments)); }
		}
	};

	var logger = config.log;


	// ************************************************
	//
	//	Usage:
	//		- compile(options)
	//		- compile(srcPath,callback)
	//		- compile(srcPath,options)
	//		- compile(srcPath,[options],[callback])
	//
	//	If options.outputPath is set, the minified js and css files
	//	will be dumped in that directory as rigging.min.js and rigging.min.css respectively.
	//	Otherwise they will be dumped in the pwd.
	//
	// ************************************************
	this.compile = function(srcPath, options, callback) {
		var c = _.extend({},config,options);
		config = normalize(srcPath, c, callback);
		async.auto(Compiler, config.callback);
	};

	/*  Adapted from wrench (https://github.com/ryanmcgrath/wrench-js/blob/master/lib/wrench.js)
	 *	ls("directory_path",/filenameRegex/);
	 *
	 *  Recursively dives through *baseDir* and read the contents of all the
	 *  children directories, where matches *filterRegex*
	 */
	this.ls = module.exports.ls = function(baseDir, filterRegex, relative) {
		// If more than one array was specified, process all of them
		if(_.isArray(baseDir)) {
			var files = [];
			_.each(baseDir, function(dir) {
				files = files.concat(helper(dir));
			});
			return files;
		} else {
			return helper(baseDir);
		}

		// Helper function


		function helper(dir) {

			// Wipe trailing slash
			dir = dir.replace(/\/$/, '');

			var lsSyncRecursive = function(baseDir) {
					var files = [],
						curFiles, nextDirs, isDir = function(fname) {
							return fs.statSync(_path.join(baseDir, fname)).isDirectory();
						},
						prependBaseDir = function(fname) {
							return _path.join(baseDir, fname);
						},
						matchesFilterRegex = function(fname) {
							return filterRegex ? fname.match(filterRegex) : true;
						};

					curFiles = fs.readdirSync(baseDir);
					nextDirs = curFiles.filter(isDir);
					curFiles = curFiles.map(prependBaseDir);

					// Only include these files if they match the specified filterRegex
					curFiles = curFiles.filter(matchesFilterRegex);

					files = files.concat(curFiles);

					while(nextDirs.length) {
						files = files.concat(lsSyncRecursive(_path.join(baseDir, nextDirs.shift())));
					}

					return files;
				};

			// Handle case where base directory is actually a file
			var fileList;
			if(!fs.statSync(dir).isDirectory()) {
				if(dir.match(filterRegex)) {
					fileList = [dir];
				} else {
					fileList = [];
				}
			} else {
				fileList = lsSyncRecursive(dir, filterRegex);
			}

			// convert absolute paths to relative
			fileList = fileList.map(function(val) {
				if(relative) {
					return _path.relative(dir, val);
				} else {
					return val;
				}
			});

			return fileList;
		}
	};

	var is = {
		js: /.+\.js$/g,
		css: /.+\.css$/g,
		less: /.+\.less$/g,
		coffee: /.+\.coffee$/g,
		sass: /.+\.(sass|scss)$/g
	};

	var Compiler = {

		// Compile coffee script files in place
		coffee: function(cb) {
			preprocessTogether(is.coffee, function(rawCoffee, cb) {
				cb(null, coffee.compile(rawCoffee));
			}, ".js", "rigging.coffee.js", cb);
		},

		// // Compile sass files in place
		// sass: function(cb) {
		// 	preprocessTogether(is.sass, sass.render, ".css", "rigging.sass.css", cb);
		// },

		// Compile less files in place
		less: function(cb) {
			preprocessTogether(is.less, less.render, ".css", "rigging.less.css", cb);
		},

		// Combine and minify js
		js: ['coffee', function(cb) {
			var filesIn;

			// If this is the command line, always combine files
			if(config.cmdLine) {
				// Delete existing file
				try {
					fs.unlinkSync(config.outputPath + "/rigging.min.js");
				} catch(e) {}

				filesIn = config.path.concat([config.outputPath + "/rigging.coffee.js"]);
				logger.verbose("Compiling files and directories in the rigging path...");
				new compressor.minify({
					type: 'gcc',
					fileIn: ls(filesIn, is.js),
					fileOut: config.outputPath + "/rigging.min.js",
					callback: cb
				});
			}
			// Only minify assets in a production environment
			else if(config.environment !== "production") {
				cb();
			} else {
				// Delete existing file
				try {
					fs.unlinkSync(config.outputPath + "/rigging.min.js");
				} catch(e) {}

				filesIn = config.path.concat([config.outputPath + "/rigging.coffee.js"]);
				logger.verbose("Compiling files and directories in the rigging path...");
				new compressor.minify({
					type: 'gcc',
					fileIn: ls(filesIn, is.js),
					fileOut: config.outputPath + "/rigging.min.js",
					callback: cb
				});
			}
		}],

		// Combine and minify css
		css: ['less', function(cb) {
			var filesIn;

			// If this is the command line, always combine files
			if(config.cmdLine) {
				// Delete existing file
				try {
					fs.unlinkSync(config.outputPath + "/rigging.min.css");
				} catch(e) {}

				filesIn = config.path.concat([config.outputPath + "/rigging.less.css"]);
				// filesIn = config.path.concat([config.outputPath + "/rigging.less.css", config.outputPath + "/rigging.sass.css"]);
				new compressor.minify({
					type: 'yui',
					fileIn: ls(filesIn, is.css),
					fileOut: config.outputPath + "/rigging.min.css",
					callback: cb
				});
			}
			// Only minify assets in a production environment
			else if(config.environment !== "production") {
				cb();
			} else {
				// Delete existing file
				try {
					fs.unlinkSync(config.outputPath + "/rigging.min.css");
				} catch(e) {}

				filesIn = config.path.concat([config.outputPath + "/rigging.less.css"]);
				// filesIn = config.path.concat([config.outputPath + "/rigging.less.css", config.outputPath + "/rigging.sass.css"]);
				logger.verbose("Compiling css from the files and directories specified in the rigging path...", filesIn);
				new compressor.minify({
					type: 'yui',
					fileIn: ls(filesIn, is.css),
					fileOut: config.outputPath + "/rigging.min.css",
					callback: cb
				});
			}
		}]
	};



	/**
	 * Marshal required options and spit out meaningful error messages if necessary
	 */

	function normalize(path, options, callback) {

		var config = (_.isObject(path) && !_.isArray(path)) ? path : _.isObject(options) ? options : {};

		// Parse path parameter
		if(_.isString(path) || _.isArray(path)) {
			_.extend(config, {
				path: path
			});
		} else if(_.isObject(path)) {
			config = _.extend(config, path);
		}

		// Parse options parameter
		if(_.isObject(options)) {
			_.extend(config, options);
		} else if(_.isFunction(options)) {
			_.extend(config, {
				callback: options
			});
		}

		// Parse callback parameter
		if(_.isFunction(callback)) {
			_.extend(config, {
				callback: callback
			});
		} else if(_.isFunction(options)) {
			_.extend(config, {
				callback: options
			});
		}

		// Validate required configuration
		if(!config.path) {
			throw new Error("No source path(s) specified!");
		} else if(!config.callback) {
			throw new Error("No callback function specified!");
		}

		// Clean up file paths
		config.outputPath = config.outputPath && rtrim(config.outputPath);
		config.path = _.isArray(config.path) ? _.map(config.path, rtrim) : [rtrim(config.path)];

		// If specified, check that output directory exists and is a real directory
		if(config.outputPath) {
			var status;
			try {
				status = fs.lstatSync(config.outputPath);
				if(status && status.isFile()) {
					debug.warn("Output directory " + config.outputPath + " is already occupied by a file.");
					process.exit(1);
				}
			}
			// Dir doesn't exist, so create it
			catch(e) {
				fs.mkdirSync(config.outputPath);
			}
		}

		return config;
	}


	/**
	 * Use a compiler to preprocess some files
	 *		- filter
	 *				ls regex to apply when recursively fetching files
	 *		- preprocessorFn(data,cb)
	 *				fn that will transform the source data
	 *					- data
	 *						the raw data to transform
	 *					- cb (err,transformedData)
	 *						a callback function w/ the transformed data
	 *		- extension
	 *				extension for destination file (includes the ".")
	 *		- destinationPath
	 *				destination for the compiled  (includes the ".")
	 *		- cb
	 *				callback fn
	 */

	function preprocessTogether(filter, preprocessorFn, extension, destinationPath, cb) {
		var aggregatedContents = "";

		// Build new destination filepath
		var destination = config.outputPath + "/" + destinationPath;

		// Touch output file so it's guaranteed to exist
		try {
			fs.unlinkSync(destination);
		} catch(e) {}
		fs.writeFileSync(destination, " \n");

		async.forEach(ls(config.path, filter), function(filepath, cb) {
			fs.readFile(filepath, 'utf8', function(err, fileContents) {
				if(err) throw err;
				aggregatedContents += "\n" + fileContents;
				cb();
			});
		}, function(err) {
			// Run transformation
			preprocessorFn(aggregatedContents, function(err, transformedData) {
				if(err) return cb(err);

				// Write destination file
				overwrite(destination, transformedData + "\n", cb);
			});
		});
	}


	/**
	 * Remove trailing slash if one exists
	 */

	function rtrim(path) {
		return _.str.rtrim(path, "/");
	}

	/**
	 * Overwrite existing file at destinationPath with new data
	 */

	function overwrite(destinationPath, data, cb) {
		try {
			fs.unlinkSync(destinationPath);
		} catch(e) {}
		fs.writeFile(destinationPath, data, cb);
	}

	return this;
}