{
  "name": "parley",
  "version": "0.0.2",
  "description": "Convention-over-configuration flow control",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikermcneil/parley.git"
  },
  "keywords": [
    "flowcontrol",
    "async",
    "promise"
  ],
  "author": {
    "name": "Mike McNeil"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "dependencies": {
    "underscore": "~1.4.2",
    "async": "~0.1.22"
  },
  "readme": "parley\n=========\n\nSerial flow control toy for Node.js\n\n## Features\n+ Simple, minimalist api\n+ Expects standard node.js semantics (i.e. callbacks are of the form `function(err,data){}` and the last argument of calling functions)\n+ Omits functionality in order to make the library easier to work with (use async for complex stuff)\n+ Line-by-line, synchronous-style code\n\n\n## Compatible functions\nFunctions compatible with parley must have a callback as their last parameter.  If you plan to work with the results of asynchronous calls (which is often), you should plan for an err and data argument.\n```\n// A parley-equivalent setTimeout\nfunction wait (ms,cb) {\n  setTimeout(cb,ms);\n}\n\n// A parley-equivalent console.log\n// (accepts deferred data as input)\nfunction log (err,data,cb) {\n  if (err) console.error(err,cb);\n  else console.log(data,cb);\n}\n```\n\n\n## Usage\n\n```\nvar parley = require ('parley');\n\n// Start a sequence\nvar $$ = new parley();\n\n// Do some asynchronous things\n$$(wait) (100);\n$$(log) (\"100 ms later...\");\n$$(wait) (100);\n$$(log) (\"200 ms later...\");\n$$(wait) (100);\n$$(log) (\"300 ms later...\");\n```\n\n\n## Deferred data\n\n```\n// Handle deferred results\nvar result = $$(apiCall) (\"http://google.com/v2\");\n\n// Result object is automatically converted to (err,data) arguments in $$(log)\n$$(log) (result);\n\n```\n\n## Parallel processes\n\nMultiple parley sequences can be run at the same time:\n\n```\n// Do a few things at once\nvar $render = new parley();\nvar $templates = new parley();\nvar $session = new parley();\n\n// Wait until the document is ready\n$render(jQuery.ready) ();\n\n// Simultaneously, go fetch templates from jQuery\n$templates(jQuery.get) ('http://templates.com', { production: true });\n\n// Also go grab logged-in session data from the server\n$session(jQuery.get) ('/user/sessionData', {});\n\n// When all sequences are complete..\nvar $done = new parley($render,$templates,$session);\n\n// Render the UI\n$done(AppUI).render ();\n$done(log) ('All done!');\n\n```\n\n\n\n\n\n## Objects\nFor convenience, objects wrapped in a parley have all of their methods converted to parley functions.  For instance, `$$(User).find(foo)` is equivalent to `$$(User.find)(foo)`\n\n```\n// Create a parley sequence\nvar $$ = new parley();\n\n// Call $$(User.find) by wrapping the User object\nvar user = $$(User).find(17);\n```\n",
  "_id": "parley@0.0.2",
  "_from": "parley@0.0.2"
}
